<article class="first">
  <div class="title">
    <h1>Elixir for Beginners</h1>
  </div>
</article>

---

[![made-with badge](https://img.shields.io/static/v1?label=Made%20with&message=Obsidian&color=7d5bed&logo=obsidian&labelColor=1a1a1a&style=flat)](https://obsidian.md/)

[![type](https://img.shields.io/static/v1?label=Type&message=blog&color=e60048&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAi0lEQVRIS+2WMQ7AIAhF/UNXrtP7rz2OYxeqTWxMTBUSxQVXfnzyQQKC8YExL7zAGCNbgIkIsIKVhBw4vbR7unR6Gp0LvwxXd2v+EvkdDpxWXpWlRTyi9/pABRyBJHEHSlxSadxSlV0SsVsqcUml2W/pynWxnsXNisHMRxrCl8qvH3ECnQDuOmy+0zwB4WNxmUKgwwAAAABJRU5ErkJggg==&labelColor=1a1a1a&style=flat)](https://pabloagn.com/blog/) [![category](https://img.shields.io/static/v1?label=Category&message=computer-science&color=e60048&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAB9UlEQVRIS6VWMU7DQBDkDAQEdrAoCISCAomCL1DxC95Azy9oeQS/oOIHVFAgREFoCHGCRSzZzEU+63LZ9W6CO/vudmZ2d9Zn1pTPaDSqut2usduHw+FpFEUv7t1fk8LNAkiPDWj3+ADuTPjNvXMxWwGzLCuqqtqwh5MkiY0xEwfOAfrEKFAWUBO4DZQDXgCEqjuouvbZUanUrocpngMMVUkKtKC+WhFQUudAUd8r1PkepJ/w7Tysn4uzkNJlascF9WOASAki6w0xrn19b3Gpps5y3kRfJADPZgr9gJSP0EgDHDiQ/Mp50PfxAmDtuQhsZmb/z0OVhwSkmGrSGp5bGRDp3EFaJ5JaiahdZ2vYNj/JkWVMgW7sgNw2yOW+99gacp7TeFE72OcUrgo4Ho93+/3+D5T9QmGHm0BNSnHgMI7jj9Ai2tElZGCK9S3S+GA4BcNNydBaIuEstu/iLJWCa+pLDm+Nz+xQAsBenucnRVG8asFq0s/Yf9YoVAI21wyn3N4I7M1A8ijWHwB42XrFqIO9YfMRlVqqyXC5ukED3nIEVJcoBXv1lmWa5gIpeeQioyTWVj1uXf0DpgKUZbmfpunXKnVnU9rWDKiTHRSDNkDu36iqIQK/Q+mxU8sBYniL/1EVoJ9Wqwo/5x6Cf9YKv6Em1XbNH5bGfSwvuRe1AAAAAElFTkSuQmCC&labelColor=1a1a1a&style=flat)](https://pabloagn.com/categories/computer-science/) [![technologies](https://img.shields.io/static/v1?label=Technologies&message=Elixir,%20VS%20Code,%20PowerShell%207&color=e60048&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVR4nM2RMW7CUBBEnUikIQUIlBJxrrQgJG7ABRBnoUkaWhpoUgWJlgNYbvz/G1dUi1ayoy87rpOtVrszs6OdLPtXlef5UNJXjHHcCwohjMzsKZ3FGN+Bq/e+c0xHGfiWtEznkg6SNnW/dIxjs0YJ2AMnM3tJSFPgHkKY17gBcAQ+zOw5A3aSbsCkdW0NnNOZY2rstpcInJ3cS/SzwGdqtSzLmdusquqtIXWsehVF8QpcJK1qmxt/TMv6wjE/z0leP27i8Ag8inT/axxtAQ+9o/zn9QD3JOiyTjnQEQAAAABJRU5ErkJggg==&labelColor=1a1a1a&style=flat)](https://pabloagn.com/technologies/) [![website article](https://img.shields.io/static/v1?label=Website&message=Post%20Link&color=e60048&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+ElEQVR4nO2VOYgUURCGR/BAI4MN1EwjI89EMDYQvNBNNNlcE0VBUdlUUSMjj2BF2UDRePDAwGzNF2GNPIYd8Hjv/6YnEHSf/FIDPTJiu4nJFBTd1Kv6/nrVBd1q/S8DJiU9AmaBm5LOSjoATPwDY0LSQUnnzDArmJOjkqclvQceSHohaR6oJC1JeiPprqT9pZSVg5pSyirH4sw5S1EzbwZwP5jTIwWBdj1meEppZ6/XOyXpCdCX9Am4Fv45Yo+Bk1VV7ag3FNz2kKC7yznvHiX4u3U6nXU55xPAW7vfHfvLmNtmW8NaFux67k0Ea03esTfJJQTj23bHgiNtPNK6jZem3Wpg46Wp23hp2q0GNl6axksjaRGYkXRF0mnHq6ra2HSk/X5/k6RDks6YEazFPwnuBS5KuirptqTnkj4CJZ4zwNFSytqBoP/2wDHgXi33A/BM0i2zzDR7SBC4LGlPr9fb5huVUlYMus45b5E0FYJfgQS8C8/Al7jJVEpp86DODLPMNDs0up7xXBQZVKLLb8CCpIfA+ZzzvpTS+lLKGuAI8DT8cClltc+c49yoWQjGL140ao25oW8QXW1IKe3KOR8Hbkh66ZtI+i7plaG+iR244JjP3HDkXnetGWbVp9XYopHtHgvwWtIPu9+BSx7bssBNDdhqX07xT/Jbz1SBBDGHAAAAAElFTkSuQmCC&labelColor=1a1a1a&style=flat)](https://pabloagn.com/blog/elixir-for-beginners/)

Elixir is a compiled, dynamically-typed, general purpose, functional programming language developed by Brazilian software developer José Valim, first released in 2012. It runs on top of the BEAM virtual machine, which is also used to implement the Erlang programming language, thus Elixir inherits many of Erlang's abstractions and methods.



In this Blog Article, we'll

We'll be using Elixir scripts which can be found in the [Blog Article Repo](https://github.com/pabloagn/blog/tree/master/computer-science/elixir-for-beginners).

---

# Table of Contents
- Why learn Elixir?
- What to expect
- Installation
- 
- Next Steps
- [Conclusions](#conclusions)
- [References](#references)
- [Copyright](#copyright)

---

# Why learn Elixir?
In an ocean of programming languages, what does this language bring to the table? Well, lets start this by noting that Elixir consistently ranks as one of the most loved programming languages.

## 1. Distributed systems and concurrency
We might have noticed that distributed software is becoming normalized as new languages implement new ways to deal with concurrency in a safe manner. This is important because some years ago, a single CPU might have been enough, but today, that's most definitely not the case, even with efficient multi-threading.

In [Elixir: The Documentary](https://www.youtube.com/watch?v=lxYFOM3UJzo), creator José Valim explains that traditional languages are sometimes bottlenecked in terms of performance and scalability because they were not designed to deploy distributed programs.

Elixir tries to solve this problem by allowing the building of scalable, fault-tolerant, and distributed applications. It achieves this through its support for concurrency and parallelism, fault-tolerance mechanisms, and distributed computing capabilities.

In this same mini documentary, Stefan Kellner, CEO of Qixxit, mentions a critical aspect of Elixir; a system involving thousands of active connections at the same time can be deployed using Elixir, and it will result in an extremely resilient implementation.

This is important since systems will only get more complex and have more moving parts as we expand; we will need battle horses that are able to process multiple connections, in a fast manner, and without errors.

## 2. Functional programming
When talking about programming paradigms, we have four relevant options:
- **Imperative:** Describes the sequence of steps a program must take to accomplish a task.
- **Procedural:** Organizes code into procedures (also known as functions or subroutines) that can be called to perform specific tasks.
- **Object-oriented:** Models programs as a collection of objects that interact with each other. Objects are instances of classes, which encapsulate data (*attributes*) and behaviors (*methods*).
- **Functional:** Computation is based on the evaluation of mathematical functions and the avoidance of mutable state and side effects. Functional programming promotes immutability, recursion, and higher-order functions.
- **Multi-paradigm:** A combination of two or more paradigms.

If we learned programming using Python, chances are, we have only been exposed to Object-Oriented programming. OOP requires a specific way of thinking about writing code, and that sticks with us the more we write in a language using OOP.

Elixir on the other hand, is a functional language, meaning it uses functional programming. This paradigm is entirely different from OOP to the very bones, thus it requires a different way of thinking when solving problems.

Shifting from OOP to functional programming is not easy, but there are a number of advantages:
- Many high-performing concurrent languages such as Scala, Haskell and Erlang use functional programming. If we already have knowledge about the paradigm, learning a new language of the same nature is much easier.
- It provides a different way to think about approaching and solving problems, because, in the end, programming is just that: solving problems.

## 3. Scalability and performance
Elixir has lightweight processes, preemptive scheduling, and a garbage collection mechanism that can handle millions of processes with low latency. It was designed to handle large interconnected systems from the ground up, and scale them in a virtually limitless manner.

## 4. Inheritance from a titan
Erlang is a language developed by Ericsson originally designed for telecoms switching. Its main emphasis is on building extremely robust and fault-tolerant distributed applications that can quickly adapt to changing requirements. Erlang has built-in support for concurrency, so huge numbers of requests can be serviced simultaneously and single software errors can be easily contained.

Elixir is built based on Erlang, and it also runs on the same VM called BEAM. This makes a statement; Elixir will handle even the most demanding tasks.

## 4. Syntax
Elixir's syntax is based on Ruby. 

## 5. Adoption
- Discord (handle massive amounts of concurrent users).
- Motorola (fault-tolerant communication systems).
- Pinterest (scale-up real-time notification system).
- Phoenix framework.

## 6. Community
Even though Elixir is not as popular as other languages, it has an active community filled up with enthusiasts and experts constantly providing information on the latest and greatest.

Also, it's open source. Adding that to the fact that the language is still niche, we can focus on learning Elixir and even making requests to submit new ideas.

Now that we're hopefully convinced that Elixir is a great language to learn and has huge potential, we can start by making some preparations.

---

# What to expect

Another thing to mention is that we'll be focusing this segment on using Mix for project creation, compilation, and running purposes. Mix is a handy tool that manages a good portion of the boilerplate code required for kickstarting our first project, as well as the creation of the required files to compile it and run it in a breeze. There are other methods for compiling and running Elixir files such as `iex` or directly with `elixir`, but we won't be covering those here.

---

# Installation
For this segment, we will need to install four main components:
- The Erlang programming language.
- The Elixir programming language.
- Visual Studio Code.
- Elixir VS Code extension.

We will also install some packages, which will come later when we get to the...

The installation and setup will be focus towards the Windows operating system. Still, a similar process can be used for macOS or Unix-like platforms.

## 1. Elixir
We will first install the latest stable release of the Elixir programming language. We can head to the official [Elixir website downloads page for Windows](https://elixir-lang.org/install.html#windows). We will click on [Download the installer](https://github.com/elixir-lang/elixir-windows-setup/releases/download/v2.4/elixir-websetup.exe). Once we have it, we'll run the executable and follow the steps below:

- If we have Microsoft Defender enabled, it will probably tell us that the installation is not secure. We will omit this warning and initialize the installer.
- We will select the latest release (*they're sorted from newest to oldest*), which at the time of this article, should be `1.14.2`.
- We will then select the version for the type of CPU architecture we have (*32-bit or 64-bit*). If we're working on a recent computer model, we will most probably have to install the 64-bit version. If unsure, we can always check our system architecture.
- The Elixir installer will automatically install the Erlang language, so we don't have to worry about that. Once we're prompted with the Erlang installation, we will select:
	- `Erlang`
	- `Associations`
	- `Erlang Documentation`
- Once the installation concludes, we will be asked if we want to add Erlang, Elixir and `escripts` to  `PATH`. We will select yes to all (*this is important because if we don't select this, our system will not be able to find the required executables for each language*).

We can verify our Elixir installation by opening a new PowerShell prompt and typing the following:

##### **Code**
```PowerShell
elixir --version
```

If all went well, we should get something like this, depending on the version we installed:

##### **Output**
```
Erlang/OTP 25 [erts-13.0.4] [source] [64-bit] [smp:20:20] [ds:20:20:10] [async-threads:1] [jit:ns]

Elixir 1.14.4 (compiled with Erlang/OTP 25)
```

## 2. VS Code
If we don't yet have VS Code installed, we can get it from the [official downloads page](https://code.visualstudio.com/download). We need to select the Windows 8, 10, 11 executable and wait for it to download. When the installation is complete, we can verify by opening the Visual Studio Code application directly from the Windows start menu. A detailed configuration guide for VS Code is out of the scope of this article but can be consulted on the [VS Code official documentation site](https://code.visualstudio.com/docs).

## 3. Elixir VS Code extension
Once we have Erlang, Elixir, and VS Code installed, we will proceed to install the Elixir VS Code Extension:
1. Open VS code and head to the Extensions menu in the left panel. We can also open the Extensions menu by using the shortcut <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>X</kbd> or by opening the command palette by typing <kbd>F1</kbd> and searching for *Extensions: Install Extensions*.
2. We will search for `ElixirLS: Elixir support and debugger`, maintained by *ElixirLS*, install it, and enable it. We can also get the extension by using [this link](https://marketplace.visualstudio.com/items?itemName=JakeBecker.elixir-ls).

We mentioned that Elixir is a compiled language, so it'll be best if we have a shell prompt also available.

Now that everything's in place, we're ready to start configuring our working environment.

---

# Creating a project
Elixir projects can be created using Mix. Mix is a build tool that provides tasks for creating, compiling, testing our application, managing its dependencies, and more.

To create a new project called `project_1`, we can open a new PowerShell session, and include the following:

##### **Code**
```PowerShell
mix new project_1
```

##### **Output**
```
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/project1.ex
* creating test
* creating test/test_helper.exs
* creating test/project1_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd project_1
    mix test

Run "mix help" for more commands.
```

This command will create a number of files and folders:
- `project_1`: The main folder for our project.
	- `.elixir_ls`: A folder containing configuration and cache files used by ElixirLS to provide advanced code editing features, such as autocompletion, code navigation, and code formatting. This folder is created by the Elixir extension we're using, in this case, ElixirLS for VS Code.
	- `lib/project1.ex`: Our project's main source file.
	- `test/project1_test.exs`: Contains an example test and serves as a starting point for writing our own tests for our application.
	- `test/test_helper.exs`: The script invoked when testing our program; Elixir uses the ExUnit testing framework, which comes built-in with the language, to write and run program tests.
	- `.formatter.exs`: A configuration file used by the Elixir code formatter. The code formatter is a tool that automatically formats Elixir code according to a set of predefined rules, making it easier to read and maintain. The `.formatter.exs` file allows us to customize the code formatter's behavior by specifying options such as line length, indentation, and syntax preferences.
	- `.gitignore`: If we're including a GitHub repository along with our project, a `.gitignore` file serves as a way to let git know which files and folders to ignore in our commits. If we have an intended repository we can leave this file. Else, we can delete it. Mix populates the project's `.gitignore` file with some helpful entries that we are not supposed to include in a GitHub repository. 
	- `mix.exs`: The project's configuration file. It is used to define the project's dependencies, version, and other metadata, as well as to configure various settings related to the build process, such as compilers and output directories.
	- `README.md`: Yet another GitHub-related file. A `README.md` file is typically used in repositories to provide information about our project. As with `.gitignore`, Mix will populate this file with some useful information. If we're not working with a GitHub repo, we can delete this file.

As we may have noted, Elixir source files have the `.ex` file extension. We can open the `lib/project1.ex` in VS Code and start writing some code.

## 1. The main source file
Upon creating our Mix project, our main file, `lib/project1.ex`, was also created and populated. It should look something like such:

##### **Code**
```Elixir
defmodule Project1 do
  @moduledoc """
  Documentation for `Project1`.
  """

  @doc """
  Hello world.

  ## Examples

      iex> Project1.hello()
      :world

  """
  def hello do
    :world
  end
end
```

The first line denotes a module declaration. This is achieved by using `defmodule projectname do end`, and is the main module of our project, 

Below the module declaration, docstrings using triple double quotes `"""` are included:
- The `@moduledoc` attribute is used to add documentation to the module.
- The `@doc` attribute is used before a function to provide documentation for it.

Finally, we have a function declaration. By default, the name of our function is `hello`, although we probably want to change that to something more transcendental. We will also take some time to write simple module and function docstrings:

##### **Code**
```Elixir
defmodule Project1 do
  @moduledoc """
  This is a module containing functions to explore the Elixir language.
  """

  @doc """
  Print hello world.
  """
  def main do
    IO.puts("Hello World")
  end
end
```

Much better, right? So now we would like to execute this project and make it print the intended message to `stdout`.

One thing to note is that, although we're defining our first function as `main`, this is just for clarity and convention purposes since Elixir does not require us to define a `main` function as with other languages.

The idea is to define a `main` function for each module, responsible for calling all the other functions in our module.

## 2. Compiling & running 
In order to run an Elixir project, we will need to compile it first. The good news is that if we're using Mix, we don't have to worry about that, since it's handled automatically when running.

We can create a new PowerShell instance, head to our project's main directory, and include the following:

##### **Code**
```PowerShell
mix run -e "Project1.main()"
```

Mix first compiles the `Project1` module and then runs `myfun1()`.

##### **Output**
```
Compiling 1 file (.ex)
Generated project_1 app
Hello World
```

And voila, we've written, compiled and run our first Elixir project.

Upon compiling and running, the compiler will create a new folder called `_build`. This folder will at first contain one subfolder called `dev`. This subfolder contains the development build artifacts. This includes compiled Elixir code, compiled Erlang code, and compiled NIFs (*Native Implemented Functions*) if our project uses them.

---

# Commenting

---

# Variables
As we have seen, we can define a variable using the following syntax:

##### **Code**
```Elixir
def main do
  # Define an integer
  myint = 13

  # Define a floating-point number
  myfloat = 3.1416

  # Define a string
  mystring = "Hello World"

  # Define a boolean
  mybool = true
end
```

It's important to remember that declared variables must be used eventually, else, the compiler will let us build our application but return a warning upon compilation. If we're not using a variable we declared, we can prefix with an underscore `_` to denote a placeholder variable.

Also, in Elixir we don't need to define a variable's data type since it's dynamically-typed.

---

# Printing
There are two main methods we can use to print to `stdout`:
- `IO.puts`: Takes a string as its argument and outputs that string to `stdout` followed by a newline character.
- `IO.inspect`: Takes a value as its argument and outputs the internal representation of that value (*an Elixir expression*) to `stdout`.

## 1. IO.puts
Elixir's syntax is similar to Ruby's; one of the similarities is that we don't require the use use parenthesis `()` in statements. This would provide us with two different ways to print to `stdout`:

##### **Code**
```Elixir
def main do
  # Define an integer
  myint = 13

  # Print with parenthesis
  IO.puts(myint)

  # Print without parenthesis
  IO.puts myint
end
```

##### **Output**
```
13
13
```

Note that we cannot print multiple variables inside one print statement by simply using a comma `,`, but we need to use either string interpolation or string concatenation.

### 1.1 Using string interpolation
We can also use string interpolation to print a string along with a variable. For this, we enclose our variable in curly brackets prepended by a hash sign `#{}` inside our print statement:

##### **Code**
```Elixir
def main do
  # Define an integer
  myint = 13
  
  # Print with string interpolation
  IO.puts("The number is: #{myint}")
end
```

##### **Output**
```
The number is: 13
```

For multiple variables, we can simply use the following syntax:

##### **Code**
```Elixir
def main do
  myint1 = 13
  myint2 = 14
  IO.puts("Numbers: #{myint1}, #{myint2}")
end
```

##### **Output**
```
Numbers: 13, 14
```

### 1.2. Using string concatenation
We can also print multiple values using one statement with string interpolation. String interpolation requires us to have the same types (`string`) for all values to print to `stdout`. If we have different data types, we must cast them when printing them:

##### **Code**
```Elixir
def main do
  # Define an integer
  myint = 13

  # Print with string concatenation
  IO.puts("The number is: " <> Integer.to_string(myint))
end
```

##### **Output**
```
The number is: 13
```

For multiple variables, we can simply use the following syntax:

##### **Code**
```Elixir
def main do
  myint1 = 13
  myint2 = 14
  IO.puts("Numbers: " <> Integer.to_string(myint1) <> ", " <> Integer.to_string(myint2))
end
```

##### **Output**
```
Numbers: 13, 14
```

## 2. IO.inspect
This method is suited specifically when we're trying to visualize the internal representation of a given value, exactly as it was originally written.

One great example would be if we have a `list` that we would like to print to `stdout` while maintaining its structure:

##### **Code**
```Elixir
def main do
  mylist = [1, 2, 3, 4, 5]

  # Inspect
  IO.inspect(mylist, label: "Inspect")

  # Puts
  IO.puts("Puts: #{mylist}")
end
```

##### **Output**
```
Inspect: [1, 2, 3, 4, 5]
Puts: ☺☻♥♦♣
```

As we can see from the second output, calling `IO.puts` on our list will result in gibberish. This is because the `IO.puts` function expects a `string` as an argument, not a `list`. When we pass a list to `IO.puts`, Elixir will try to convert the list to a string, but the result may not be what we expect.

Another important thing to note, is that we used the `label` option for `IO.inspect`. In this method, we cannot use string interpolation `#{}`, thus we cannot append additional strings like we did with `IO.puts`. To achieve this, we need to use the `label` property, which will behave exactly the same as with `IO.puts`.

---

# Data types
Elixir has multiple data types we can make use of. 

Let us 

https://www.youtube.com/watch?v=pBNOavRoNL0&t=300



## 1. Integers
Integers do not have limit on their size. They can be defined by simply assigning the value to a variable.

We can perform all of the expected arithmetic operations on integer values:

##### **Code**
```Elixir
def main do
  # Define ints
  myint1 = 14
  myint2 = 7
  IO.puts("Ints: #{myint1}, #{myint2}")

  # Arithmetic operations
  IO.puts("Addition: #{myint1 + myint2}")
  IO.puts("Subtraction: #{myint1 - myint2}")
  IO.puts("Product: #{myint1 * myint2}")
  IO.puts("Division returning int or float: #{myint1 / myint2}")
  IO.puts("Division returning int: #{div(myint1, 8)}")
  IO.puts("Remanent: #{rem(myint1, myint2)}")
  IO.puts("Exponentiation: #{myint1**2}")
end
```

##### **Output**
```
Addition: 21
Subtraction: 7
Product: 98
Division returning int or float: 2.0
Division returning int: 1
Remanent: 0
Exponentiation: 196
```

Note that the `div` operator returns a truncated integer value, meaning the result is not rounded; only the integer part is taken.

We can also perform logical comparisons between integer values. We'll discuss this in detail when we get to logical operators.

## 2. Floats
Floats are accurate to 16 decimal places. They can be defined either using decimal or scientific notation:

##### **Code**
```Elixir
def main do
  # Define float
  myfloat1 = 1200.0
  IO.puts("Float: #{myfloat1}")

  # Define float using scientific notation
  myfloat2 = 12.0e2
  IO.puts("Float Scientific: #{myfloat2}")
end
```

##### **Output**
```
Float: 1.2e3
Float Scientific: 1.2e3
```

And can also be operated on using the same arithmetic and logical operators we used above for integer values.

## 3. Strings
We have already defined some strings in previous sections. It's worth pointing out that strings are defined using double quotes `""`.  

We can define a string and perform some useful operations:

##### **Code**
```Elixir
def main do
  # Declare some strings
  mystr1 = "Elixir"
  mystr2 = "is"
  mystr3 = "awesome"

  # Get length of string
  IO.puts("Len: #{String.length(mystring)}")

  # Concatenate strings
  mystr4 = mystr1 <> " " <> mystr2 <> " " <> mystr3 <> "."
  IO.puts("Concatenated: #{mystr4}")

  # Convert to uppercase
  mystr5 = String.upcase(mystr4)
  IO.puts("Upper: #{mystr5}")

  # Go back to lowercase (downcase)
  IO.puts("Lower: #{String.downcase(mystr5)}")

  # Capitalize first characters
  IO.puts("Capitalize: #{String.capitalize(mystr5)}")

  # Check if strings are equal (value and datatype ===)
  IO.puts("Strings are equal?...#{mystr4 === mystr5}")

  # Check if string contains another string
  targetstring = "awesome"
  IO.puts("String contains #{targetstring}?: #{String.contains?(mystr4, targetstring)}")

  # Return first character
  IO.puts("First character: #{String.first(mystr5)}")

  # Index a character inside a string
  IO.puts("Second character: #{String.at(mystr5, 1)}")

  # Get substring using slice (from index 0 to 6)
  IO.puts("String slice: #{String.slice(mystr5, 0, 6)}")

  # Reverse string
  IO.puts("Reverse string: #{String.reverse(mystr5)}")
end
```

##### **Output**
```
Len: 5
Concatenated: Elixir is awesome.
Upper: ELIXIR IS AWESOME.
Lower: elixir is awesome.
Capitalize: Elixir is awesome.
Strings are equal?...false
String contains awesome?: true
First character: E
Second character: L
String slice: ELIXIR
Reverse string: .EMOSEWA SI RIXILE
```

## 4. Atoms
In Elixir, an atom is a constant whose value is its own name. An atom is written by starting with a colon `:` followed by a sequence of characters. For example, `:hello`, `:world`, and `:Mexico` are all atoms.

Atoms are useful when...

```Elixir
def main do
  # Declare atom without space
  myatom1 = :Hello

  # Declare atom with space
  myatom2 = :"Mexico City"

  # Print atoms
  IO.puts("#{myatom1}, #{myatom2}")

  # Check types
  IO.puts("#{is_atom(myatom1)}, #{is_atom(myatom1)}")
end
```

##### **Output**
```
Hello, Mexico City
true, true
```

## 5. Lists
As we venture into sequence data types, it's worth pointing out that Elixir uses 0-based indexing, whereas Erlang uses 1-based indexing.



## 6. Tuples

## 7. Ranges
A `range` is a data type that represents an interval of values. A range can also be used as an input to various iterators, such as `Enum.each/2`, `Enum.map/2`, `Enum.filter/2`, and `Enum.reduce/3`, which we'll review in more depth as we discuss iterators.

Ranges represent a sequence of zero, one or many, ascending or descending integers with a common difference called step. They are always inclusive and they may have a custom step defined.

A simple range can be defined as follows:

##### **Code**
```Elixir
def main do
  myrange = 1..100
end
```


## 8. Maps


## 9. Checking types
There's no direct way to get the type of a variable in Elixir/Erlang. We usually want to know the type of a variable in order to act accordingly. We can check if a variable is of a given type by using the `is_type` method, where `type` must be substituted with the appropriate type name:

##### **Code**
```Elixir
def main do
  # Declare variables
  myint = 20
  myfloat = 20.13
  mystring = "Hello"
  mybool = true

  # Check if type is int
  IO.puts("Is #{myint} an integer number?: #{is_integer(myint)}")

  # Check if type is float
  IO.puts("Is #{myfloat} a floating-point number?: #{is_float(myfloat)}")

  # Check if type is string
  IO.puts("Is #{mystring} a string?: #{is_bitstring(mystring)}")

  # Check if type is bool
  IO.puts("Is #{mybool} a boolean?: #{is_boolean(mybool)}")
end
```

##### **Output**
```
Is 20 an integer number?: true
Is 20.13 a floating-point number?: true
Is Hello a string?: true
Is true a boolean?: true
```

---

# Operators



## 1. Comparison operators
Elixir provides all the comparison operators we would expect from any language, plus some additional operators referring to data type comparisons:

| Operator | Description                          |
| -------- | ------------------------------------ |
| `===`     | Value and data type are equal to     |
| `==`      | Value is equal to                    |
| `!==`      | Value and data type are not equal to |
| `!=`       | Value is not equal to                |
| `>`       | Value is greater than                |
| `<`        | Value is less than                   |
| `>=`      | Value is greater than or equal to    |
| `<=`       | Value is less than or equal to       |

###### *Table n: Basic Comparison operators*

We can make some comparisons:

##### **Code**
```Elixir
def main do
  # Define int and float
  myint = 7
  myfloat = 7.0

  # Compare values
  IO.puts("===: #{myint === myfloat}")
  IO.puts("==: #{myint == myfloat}")
  IO.puts("!==: #{myint !== myfloat}")
  IO.puts("!=: #{myint != myfloat}")
  IO.puts(">: #{myint > myfloat}")
  IO.puts("<: #{myint < myfloat}")
  IO.puts(">=: #{myint >= myfloat}")
  IO.puts("<=: #{myint <= myfloat}")
end
```

##### **Output**
```
===: false
==: true
!==: true
!=: false
>: false
<: false
>=: true
<=: true
```

## 2. Arithmetic operators
Elixir brings in the usual algebraic operators we would expect from any language:

| Operator | Description                         |
| -------- | ----------------------------------- |
| `+`        | Addition                            |
| `-`       | Subtraction                         |
| `*`       | Product                             |
| `/`        | Division (returns result as `float`)  |
| `div`      | Division (returns truncated result as `int`) |
| `rem`      | Reminder                            |
| `**`     | Exponentiation                      |

###### *Table n: Basic arithmetic operators*


Additionally, Elixir also has special methods for special data types such as `lists`:




---

# Iterators


---

# Pipes
For those already familiar with piping in `bash` or `zsh`, pipes are a convenient syntax for chaining together functions in a way that makes the code more readable and easier to understand. Pipes allow us to pass the output of one function as the input to another function, without the need for nested function calls or temporary variables.

Although bash is mostly defined as a procedural language, pipes are common in functional languages; they go well with the functional programming philosophy where we write chains of functions.

We can pipe in Elixir by using the `|>` operator.

---

## Modules

---

## Functions

---

# Conclusions
We've reviewed multiple yet simple mechanisms we can employ to make our code cleaner, more elegant, modular, usable, scalable and safer. These measures can not only help us become better programmers but better collaborators. It will make reading code a pleasure instead of an agonizing process and instantly boost our credibility.

---

# References
- [Elixir: The Documentary](https://www.youtube.com/watch?v=lxYFOM3UJzo)
- https://www.youtube.com/watch?v=antnsMgA4Ro
- https://www.youtube.com/watch?v=pBNOavRoNL0

---

# Copyright
Pablo Aguirre, Creative Commons Attribution 4.0 International, All Rights Reserved.